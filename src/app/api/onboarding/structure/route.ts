// src/app/api/onboarding/structure/route.ts

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
// IMPORTANTE: Importar el DepartmentAdapter real que ya existe en tu proyecto
import { DepartmentAdapter } from '@/lib/services/DepartmentAdapter'

/**
 * API ENDPOINT: Guardar Estructura Organizacional
 * SOLO PARA ADMINISTRADORES FOCALIZAHR_ADMIN
 * 
 * PRINCIPIOS ARQUITECT√ìNICOS:
 * 1. NUNCA asignar standard_category directamente
 * 2. Usar niveles correctos: Level 1 = CEO, Level 2 = Gerencias, Level 3 = Departamentos
 * 3. DepartmentAdapter es la √öNICA fuente de verdad para categor√≠as
 * 4. Proceso en 2 fases: crear estructura, luego asignar categor√≠as
 * 5. SOLO administradores pueden crear estructuras para clientes
 */

export async function POST(request: NextRequest) {
  try {
    // ==========================================
    // FASE 1: VERIFICACI√ìN DE AUTENTICACI√ìN Y AUTORIZACI√ìN ADMIN
    // ==========================================
    const authHeader = request.headers.get('Authorization')
    const { validateAuthToken } = await import('@/lib/auth')
    const validation = await validateAuthToken(authHeader, request)
    
    if (!validation.success || !validation.account) {
      return NextResponse.json(
        { error: validation.error || 'No autorizado' },
        { status: 401 }
      )
    }
    
    // VERIFICAR ROL ADMIN - SOLO FOCALIZAHR_ADMIN PUEDE CREAR ESTRUCTURAS
    if (validation.account.role !== 'FOCALIZAHR_ADMIN') {
      return NextResponse.json(
        { error: 'Acceso denegado - Solo administradores de FocalizaHR pueden crear estructuras' },
        { status: 403 }
      )
    }
    
    const decoded = validation.account
    
    // ==========================================
    // FASE 2: OBTENER Y VALIDAR DATOS
    // ==========================================
    const body = await request.json()
    const { structure } = body
    
    // Usar accountId del body (admin especifica para qu√© cuenta es)
    const accountId = body.accountId || decoded.id
    
    if (!accountId) {
      return NextResponse.json(
        { error: 'AccountId no encontrado en token' }, 
        { status: 400 }
      )
    }
    
    if (!structure?.gerencias || !Array.isArray(structure.gerencias)) {
      return NextResponse.json(
        { error: 'Estructura inv√°lida: gerencias requeridas' }, 
        { status: 400 }
      )
    }
    
    // Verificar que la cuenta existe - CORRECCI√ìN: usar prisma.account
    const account = await prisma.account.findUnique({
      where: { id: accountId }
    })
    
    if (!account) {
      return NextResponse.json(
        { error: 'Cuenta no encontrada' }, 
        { status: 404 }
      )
    }
    
    // ==========================================
    // FASE 3: LIMPIAR ESTRUCTURA EXISTENTE (OPCIONAL)
    // ==========================================
    // Comentario: Decidir si queremos eliminar estructura anterior
    // o mantener hist√≥rico. Por ahora, eliminamos para evitar duplicados
    
    const existingDepartments = await prisma.department.count({
      where: { accountId: accountId }  // CORRECCI√ìN: accountId en camelCase
    })
    
    if (existingDepartments > 0) {
      console.log(`‚ö†Ô∏è Eliminando ${existingDepartments} departamentos existentes para cuenta ${accountId}`)
      await prisma.department.deleteMany({
        where: { accountId: accountId }  // CORRECCI√ìN: accountId en camelCase
      })
    }
    
    // ==========================================
    // FASE 4: CREAR ESTRUCTURA SIN CATEGOR√çAS
    // ==========================================
    console.log('üì¶ Creando estructura organizacional...')
    
    // ============ PASO 4: BUSCAR O CREAR CEO ============
    // Buscar el CEO/Nivel 1 de esta cuenta
    const ceo = await prisma.department.findFirst({
      where: {
        accountId: accountId,
        level: 1,
        unitType: 'direccion'
      }
    });

    // Si no existe CEO (empresas creadas antes del cambio), crearlo
    let ceoId = ceo?.id;
    if (!ceo) {
      console.log('‚ö†Ô∏è No se encontr√≥ CEO, creando uno...');
      const newCeo = await prisma.department.create({
        data: {
          accountId: accountId,
          displayName: 'Gerencia General',
          unitType: 'direccion',
          level: 1,
          isActive: true,
          parentId: null,
          standardCategory: null,
          employeeCount: 0,
          technicalComplexity: 'media',
          emotionalComplexity: 'media',
          marketScarcity: 'normal'
        }
      });
      ceoId = newCeo.id;
      console.log('‚úÖ CEO nivel 1 creado retroactivamente');
    } else {
      console.log('‚úÖ CEO existente encontrado');
    }
    // ============ FIN PASO 4 ============
    
    const createdGerencias = []
    const createdDepartments = []
    
    for (const gerencia of structure.gerencias) {
      // Validar datos de gerencia
      if (!gerencia.displayName?.trim()) {
        console.warn('‚ö†Ô∏è Gerencia sin nombre, saltando...')
        continue
      }
      
      // CREAR GERENCIA - SIN standard_category, CON parentId al CEO
      const ger = await prisma.department.create({
        data: {
          accountId: accountId,  // CORRECCI√ìN: accountId en camelCase
          displayName: gerencia.displayName.trim(),  // CORRECCI√ìN: displayName en camelCase
          unitType: 'gerencia',  // CORRECCI√ìN: unitType en camelCase
          level: 2,  // ‚úÖ CORRECTO: Level 2 para gerencias
          parentId: ceoId,  // ‚úÖ AGREGADO: Las gerencias son hijas del CEO
          isActive: true,  // CORRECCI√ìN: isActive en camelCase
          // Campos opcionales con valores por defecto
          employeeCount: 0,  // CORRECCI√ìN: employeeCount en camelCase
          technicalComplexity: 'media',  // CORRECCI√ìN: technicalComplexity en camelCase
          emotionalComplexity: 'media',  // CORRECCI√ìN: emotionalComplexity en camelCase
          marketScarcity: 'normal',  // CORRECCI√ìN: marketScarcity en camelCase
          // ‚ùå NO asignamos standard_category aqu√≠
        }
      })
      
      createdGerencias.push(ger)
      console.log(`‚úÖ Gerencia creada: ${ger.displayName} (ID: ${ger.id})`)
      
      // CREAR DEPARTAMENTOS HIJOS
      if (gerencia.departments && Array.isArray(gerencia.departments)) {
        for (const dept of gerencia.departments) {
          if (!dept.displayName?.trim()) {
            console.warn('‚ö†Ô∏è Departamento sin nombre, saltando...')
            continue
          }
          
          const createdDept = await prisma.department.create({  // CORRECCI√ìN: department singular
            data: {
              accountId: accountId,  // CORRECCI√ìN: accountId en camelCase
              displayName: dept.displayName.trim(),  // CORRECCI√ìN: displayName en camelCase
              parentId: ger.id,  // CORRECCI√ìN: parentId en camelCase - Referencia a la gerencia padre
              unitType: 'departamento',  // CORRECCI√ìN: unitType en camelCase
              level: 3,  // ‚úÖ CORRECTO: Level 3 para departamentos
              isActive: true,  // CORRECCI√ìN: isActive en camelCase
              // Campos opcionales con valores por defecto
              employeeCount: 0,  // CORRECCI√ìN: employeeCount en camelCase
              technicalComplexity: 'media',  // CORRECCI√ìN: technicalComplexity en camelCase
              emotionalComplexity: 'media',  // CORRECCI√ìN: emotionalComplexity en camelCase
              marketScarcity: 'normal',  // CORRECCI√ìN: marketScarcity en camelCase
              // ‚ùå NO asignamos standard_category aqu√≠
            }
          })
          
          createdDepartments.push(createdDept)
          console.log(`  ‚úÖ Departamento creado: ${createdDept.displayName} (Padre: ${ger.displayName})`)
        }
      }
    }
    
    console.log(`üìä Estructura creada: ${createdGerencias.length} gerencias, ${createdDepartments.length} departamentos`)
    
    // ==========================================
    // FASE 5: ASIGNAR CATEGOR√çAS CON DEPARTMENTADAPTER
    // ==========================================
    console.log('üè∑Ô∏è Asignando categor√≠as est√°ndar usando DepartmentAdapter...')
    
    // Obtener TODOS los departamentos creados (incluyendo CEO, gerencias y departamentos)
    const allDepts = await prisma.department.findMany({  // CORRECCI√ìN: department singular
      where: { accountId: accountId },  // CORRECCI√ìN: accountId en camelCase
      orderBy: { level: 'asc' }  // Procesar por nivel: CEO primero, luego gerencias, luego departamentos
    })
    
    let categorizedCount = 0
    let uncategorizedCount = 0
    
    for (const dept of allDepts) {
      try {
        // El CEO (nivel 1) no necesita categor√≠a
        if (dept.level === 1) {
          console.log(`‚è≠Ô∏è CEO "${dept.displayName}" - Sin categorizaci√≥n necesaria`)
          continue
        }
        
        // USAR EL DEPARTMENTADAPTER - √önica fuente de verdad
        // El DepartmentAdapter tiene la l√≥gica de mapeo centralizada
        const category = DepartmentAdapter.getGerenciaCategory(dept.displayName)  // CORRECCI√ìN: displayName en camelCase
        
        if (category && category !== 'sin_asignar') {
          await prisma.department.update({  // CORRECCI√ìN: department singular
            where: { id: dept.id },
            data: { standardCategory: category }  // CORRECCI√ìN: standardCategory en camelCase
          })
          categorizedCount++
          console.log(`  ‚úÖ ${dept.displayName} ‚Üí categor√≠a: ${category}`)
        } else {
          // Marcar para revisi√≥n manual posterior
          await prisma.department.update({  // CORRECCI√ìN: department singular
            where: { id: dept.id },
            data: { 
              standardCategory: 'sin_asignar'  // CORRECCI√ìN: standardCategory en camelCase
            }
          })
          uncategorizedCount++
          console.log(`  ‚ö†Ô∏è ${dept.displayName} ‚Üí sin_asignar (requiere mapeo manual)`)
        }
      } catch (error) {
        console.error(`‚ùå Error asignando categor√≠a a ${dept.displayName}:`, error)
        // Continuar con el siguiente departamento
      }
    }
    
    console.log(`üè∑Ô∏è Categorizaci√≥n completada: ${categorizedCount} categorizados, ${uncategorizedCount} sin asignar`)
    
    // ==========================================
    // FASE 6: GENERAR ESTAD√çSTICAS Y RESPUESTA
    // ==========================================
    const stats = await prisma.department.groupBy({  // CORRECCI√ìN: department singular
      by: ['unitType'],  // CORRECCI√ìN: unitType en camelCase
      where: { accountId: accountId },  // CORRECCI√ìN: accountId en camelCase
      _count: true
    })
    
    const categoryStats = await prisma.department.groupBy({  // CORRECCI√ìN: department singular
      by: ['standardCategory'],  // CORRECCI√ìN: standardCategory en camelCase
      where: { 
        accountId: accountId,  // CORRECCI√ìN: accountId en camelCase
        standardCategory: { not: null }  // CORRECCI√ìN: standardCategory en camelCase
      },
      _count: true
    })
    // ELIMINADO: El campo organizationStructure NO existe en el schema Account
    // No hay necesidad de actualizar la cuenta aqu√≠
    
    // ==========================================
    // FASE 7: RESPUESTA EXITOSA
    // ==========================================
    return NextResponse.json({
      success: true,
      message: 'Estructura organizacional creada exitosamente',
      stats: {
        gerencias: stats.find(s => s.unitType === 'gerencia')?._count || 0,  // CORRECCI√ìN: unitType en camelCase
        departamentos: stats.find(s => s.unitType === 'departamento')?._count || 0,  // CORRECCI√ìN: unitType en camelCase
        total: allDepts.length
      },
      categorization: {
        categorized: categorizedCount,
        uncategorized: uncategorizedCount,
        byCategory: categoryStats.map(c => ({
          category: c.standardCategory,  // CORRECCI√ìN: standardCategory en camelCase
          count: c._count
        }))
      },
      nextStep: '/dashboard',
      timestamp: new Date().toISOString()
    })
    
  } catch (error) {
    console.error('‚ùå Error en API de estructura:', error)
    
    // Manejo de errores espec√≠ficos de Prisma
    if (error instanceof Error) {
      if (error.message.includes('P2002')) {
        return NextResponse.json(
          { error: 'Estructura duplicada detectada' },
          { status: 409 }
        )
      }
      if (error.message.includes('P2025')) {
        return NextResponse.json(
          { error: 'Registro no encontrado' },
          { status: 404 }
        )
      }
    }
    
    // Error gen√©rico
    return NextResponse.json(
      { 
        error: 'Error interno al crear estructura organizacional',
        details: process.env.NODE_ENV === 'development' ? error : undefined
      },
      { status: 500 }
    )
  }
}

/**
 * GET: Obtener estructura actual de la cuenta
 */
export async function GET(request: NextRequest) {
  try {
    // Verificar autenticaci√≥n y rol admin
    const authHeader = request.headers.get('Authorization')
    const { validateAuthToken } = await import('@/lib/auth')
    const validation = await validateAuthToken(authHeader, request)
    
    if (!validation.success || !validation.account) {
      return NextResponse.json(
        { error: validation.error || 'No autorizado' },
        { status: 401 }
      )
    }
    
    // SOLO ADMIN PUEDE VER ESTRUCTURAS
    if (validation.account.role !== 'FOCALIZAHR_ADMIN') {
      return NextResponse.json(
        { error: 'Acceso denegado - Solo administradores' },
        { status: 403 }
      )
    }
    
    // Admin puede especificar qu√© cuenta ver
    const searchParams = request.nextUrl.searchParams
    const accountId = searchParams.get('accountId') || validation.account.id
    
    // Obtener estructura actual
    const structure = await prisma.department.findMany({  // CORRECCI√ìN: department singular
      where: { 
        accountId: accountId,  // CORRECCI√ìN: accountId en camelCase
        unitType: 'gerencia'  // CORRECCI√ìN: unitType en camelCase
      },
      include: {
        children: {
          where: { unitType: 'departamento' }  // CORRECCI√ìN: unitType en camelCase
        }
      },
      orderBy: { displayName: 'asc' }  // CORRECCI√ìN: displayName en camelCase
    })
    
    // Formatear respuesta
    const formattedStructure = {
      model: structure.length > 1 ? 'hierarchical' : 'simple',
      gerencias: structure.map(ger => ({
        id: ger.id,
        displayName: ger.displayName,  // CORRECCI√ìN: displayName en camelCase
        standardCategory: ger.standardCategory,  // CORRECCI√ìN: standardCategory en camelCase
        departments: ger.children.map(dept => ({
          id: dept.id,
          displayName: dept.displayName,  // CORRECCI√ìN: displayName en camelCase
          standardCategory: dept.standardCategory  // CORRECCI√ìN: standardCategory en camelCase
        }))
      }))
    }
    
    return NextResponse.json({
      success: true,
      structure: formattedStructure,
      timestamp: new Date().toISOString()
    })
    
  } catch (error) {
    console.error('Error obteniendo estructura:', error)
    return NextResponse.json(
      { error: 'Error al obtener estructura' },
      { status: 500 }
    )
  }
}